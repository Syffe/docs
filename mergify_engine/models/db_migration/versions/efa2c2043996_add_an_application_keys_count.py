"""add an application_keys_count

Revision ID: efa2c2043996
Revises: cdde18b1072d
Create Date: 2023-09-19 14:20:28.292026

"""
import alembic
from alembic_utils.pg_function import PGFunction
from alembic_utils.pg_trigger import PGTrigger
import sqlalchemy


revision = "efa2c2043996"
down_revision = "a4ec6d00ccfa"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    alembic.op.add_column(
        "github_account",
        sqlalchemy.Column(
            "application_keys_count",
            sqlalchemy.Integer(),
            server_default="0",
            nullable=False,
        ),
    )
    alembic.op.execute(
        "update github_account set application_keys_count = (select count(*) from application where application.github_account_id = github_account.id)",
    )

    # ### commands auto generated by Alembic - please adjust! ###
    public_increase_application_keys_count = PGFunction(
        schema="public",
        signature="increase_application_keys_count()",
        definition="returns TRIGGER AS $$\nDECLARE\n    current_count INTEGER;\nBEGIN\n    -- Get the current application_keys_count for the related github_account and lock the row for update\n    SELECT application_keys_count INTO current_count\n    FROM github_account\n    WHERE github_account.id = NEW.github_account_id\n    FOR UPDATE;\n\n    -- Check if the application_keys_count is less than APPLICATIONS_LIMIT\n    IF current_count < 200 THEN\n        -- Increase the application_keys_count by 1\n        UPDATE github_account\n        SET application_keys_count = current_count + 1\n        WHERE id = NEW.github_account_id;\n\n        -- Allow the insertion\n        RETURN NEW;\n    ELSE\n        -- Reject the insertion if the count is 200 or more\n        RAISE EXCEPTION 'CUSTOM_PG_EXCEPTION' USING DETAIL = 'ApplicationKeyLimitReached';\n    END IF;\n\n    RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql",
    )
    alembic.op.create_entity(public_increase_application_keys_count)  # type: ignore[attr-defined]

    public_decrease_application_keys_count = PGFunction(
        schema="public",
        signature="decrease_application_keys_count()",
        definition="returns TRIGGER AS $$\nBEGIN\n    UPDATE github_account\n    SET application_keys_count = application_keys_count - 1\n    WHERE id = OLD.github_account_id;\n    RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql",
    )
    alembic.op.create_entity(public_decrease_application_keys_count)  # type: ignore[attr-defined]

    public_application_trigger_increase_application_keys_count = PGTrigger(
        schema="public",
        signature="trigger_increase_application_keys_count",
        on_entity="public.application",
        is_constraint=False,
        definition="BEFORE INSERT ON public.application FOR EACH ROW EXECUTE FUNCTION increase_application_keys_count()",
    )
    alembic.op.create_entity(public_application_trigger_increase_application_keys_count)  # type: ignore[attr-defined]

    public_application_trigger_decrease_application_keys_count = PGTrigger(
        schema="public",
        signature="trigger_decrease_application_keys_count",
        on_entity="public.application",
        is_constraint=False,
        definition="BEFORE DELETE ON public.application FOR EACH ROW EXECUTE FUNCTION decrease_application_keys_count()",
    )
    alembic.op.create_entity(public_application_trigger_decrease_application_keys_count)  # type: ignore[attr-defined]
    # ### end Alembic commands ###


def downgrade() -> None:
    # NOTE(sileht): We don't want to support downgrades as it means we will
    # drop columns. And we don't want to provide tooling that may drop data.
    # For restoring old version of the database, the only supported process is
    # to use a backup.
    pass
