{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "MergifyConfig#",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "shared": {
      "type": [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    "defaults": {
      "type": "object",
      "properties": {
        "actions": {
          "$ref": "#/definitions/Actions"
        }
      }
    },
    "extends": {
      "type": "string"
    },
    "queue_rules": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/QueueRule"
      }
    },
    "partition_rules": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/PartitionRule"
      }
    },
    "pull_request_rules": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/PullRequestRule"
      }
    }
  },
  "title": "MergifyConfig",
  "definitions": {
    "PullRequestAttribute": {
      "enum": [
        {
          "key": "approved-reviews-by",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The list of GitHub user or team login that approved the pull request. Team logins are prefixed with the `@` character and must belong to the repository organization. This only matches reviewers with `admin`, `write` or `maintain` permission on the repository."
        },
        {
          "key": "assignee",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The list of GitHub user or team login that are assigned to the pull request. Team logins are prefixed with the `@` character and must belong to the repository organization."
        },
        {
          "key": "author",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The GitHub user or team login of the author of the pull request. Team logins are prefixed with the `@` character and must belong to the repository organization."
        },
        {
          "key": "base",
          "$ref": "#/definitions/BranchName",
          "description": "The name of the branch the pull request should be pulled into."
        },
        {
          "key": "body",
          "type": "string",
          "description": "The content of the pull request description without Markdown/HTML comments."
        },
        {
          "key": "body-raw",
          "type": "string",
          "description": "The content of the pull request description."
        },
        {
          "key": "branch-protection-review-decision",
          "type": "string",
          "enum": [
            "APPROVED",
            "CHANGES_REQUESTED",
            "REVIEW_REQUIRED"
          ],
          "description": "The review decision. This indicates if `CODEOWNERS` have reviewed the pull request when the Require Review from Code Owners branch protection rule is enabled."
        },
        {
          "key": "changes-requested-reviews-by",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The list of GitHub user or team login that have requested changes in a review for the pull request. Team logins are prefixed with the @ character and must belong to the repository organization. This only matches reviewers with admin, write or maintain permission on the repository."
        },
        {
          "key": "check-failure",
          "type": "string",
          "description": "The list of status checks that failed for the pull request. This is the name of a status check such as continuous-integration/travis-ci/pr or of a check run such as Travis CI - Pull Request. See About Status Checks for more details. Checks that report being cancelled, timed out, and action required are also considered as failures."
        },
        {
          "key": "check-neutral",
          "type": "string",
          "description": "The list of status checks that are neutral for the pull request. This is the name of a status check such as continuous-integration/travis-ci/pr or of a check run such as Travis CI - Pull Request. See About Status Checks for more details."
        },
        {
          "key": "check-pending",
          "type": "string",
          "description": "The list of status checks that is pending for the pull request. This is the name of a status check such as continuous-integration/travis-ci/pr or of a check run such as Travis CI - Pull Request. See About Status Checks for more details."
        },
        {
          "key": "check-skipped",
          "type": "string",
          "description": "The list of status checks that was skipped for the pull request. This is the name of a status check such as continuous-integration/travis-ci/pr or of a check run such as Travis CI - Pull Request. See About Status Checks for more details."
        },
        {
          "key": "check-stale",
          "type": "string",
          "description": "The list of status checks that are stale for the pull request. This is the name of a status check such as continuous-integration/travis-ci/pr or of a check run such as Travis CI - Pull Request. See About Status Checks for more details."
        },
        {
          "key": "check-success",
          "type": "check",
          "description": "The list of status checks that successfully passed for the pull request. This is the name of a status check such as continuous-integration/travis-ci/pr or of a check run such as Travis CI - Pull Request. See About Status Checks for more details."
        },
        {
          "key": "check-timed-out",
          "type": "string",
          "description": "The list of status checks that timed out for the pull request. This is the name of a status check such as continuous-integration/travis-ci/pr or of a check run such as Travis CI - Pull Request. See About Status Checks for more details."
        },
        {
          "key": "closed",
          "type": "boolean",
          "description": "Whether the pull request is closed."
        },
        {
          "$ref": "#/definitions/TimestampOrRelativeTimestamp",
          "key": "closed-at",
          "description": "The time the pull request was closed at."
        },
        {
          "key": "commented-reviews-by",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The list of GitHub user or team login that have commented in a review for the pull request. Team logins are prefixed with the @ character and must belong to the repository organization. This only matches reviewers with admin, write or maintain permission on the repository."
        },
        {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CommitAuthor"
          },
          "key": "co-authors",
          "description": "The list of co-authors on the pull request (excluding merge commits and bots)."
        },
        {
          "key": "commits",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Commit"
          },
          "description": "The list of commits of the pull request. The index 0 is the first commit of the pull request, while -1 is the last commit of the pull request."
        },
        {
          "key": "commits-behind",
          "type": "string",
          "description": "The list of commits between the head of the base branch and the base of the pull request. This can only be used with the length operator as #commits-behind."
        },
        {
          "key": "commits-unverified",
          "type": "string",
          "description": "The list of commit messages that are marked as unverified by GitHub."
        },
        {
          "key": "conflict",
          "type": "boolean",
          "description": "Whether the pull request is conflicting with its base branch."
        },
        {
          "$ref": "#/definitions/TimestampOrRelativeTimestamp",
          "key": "created-at",
          "description": "The time the pull request was created at."
        },
        {
          "$ref": "#/definitions/TimestampOrTimestampInterval",
          "key": "current-datetime",
          "description": "The current date and time."
        },
        {
          "key": "dependabot-dependency-name",
          "type": "string",
          "description": "The dependency-name value included in the Dependabot commit message."
        },
        {
          "key": "dependabot-dependency-type",
          "type": "string",
          "description": "The dependency-type value included in the Dependabot commit message."
        },
        {
          "key": "dependabot-update-type",
          "type": "string",
          "description": "The update-type value included in the Dependabot commit message."
        },
        {
          "key": "dismissed-reviews-by",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The list of GitHub user or team login that have their review dismissed in the pull request. Team logins are prefixed with the @ character and must belong to the repository organization. This only matches reviewers with admin, write or maintain permission on the repository."
        },
        {
          "key": "draft",
          "type": "boolean",
          "description": "Whether the pull request is in draft state."
        },
        {
          "key": "files",
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The files that are modified, deleted or added by the pull request."
        },
        {
          "key": "added-files",
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The files that are added by the pull request."
        },
        {
          "key": "modified-files",
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The files that are modified by the pull request."
        },
        {
          "key": "removed-files",
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The files that are removed by the pull request."
        },
        {
          "key": "head",
          "$ref": "#/definitions/BranchName",
          "description": "The name of the branch where the pull request changes are implemented."
        },
        {
          "key": "label",
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The list of labels of the pull request."
        },
        {
          "key": "linear-history",
          "type": "boolean",
          "description": "Whether the pull request commits history is linear (no merge commit)."
        },
        {
          "key": "locked",
          "type": "boolean",
          "description": "Whether the pull request is locked."
        },
        {
          "key": "merged",
          "type": "boolean",
          "description": "Whether the pull request is merged. This attribute doesn't work on pull requests merged before a rule using this attribute is created."
        },
        {
          "$ref": "#/definitions/TimestampOrRelativeTimestamp",
          "key": "merged-at",
          "description": "The time the pull request was merged at."
        },
        {
          "key": "merged-by",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The GitHub user or team login that merged the pull request. Team logins are prefixed with the @ character and must belong to the repository organization."
        },
        {
          "key": "milestone",
          "type": "string",
          "description": "The milestone title associated to the pull request."
        },
        {
          "key": "number",
          "type": "string",
          "description": "The pull request number."
        },
        {
          "key": "queue-partition-name",
          "type": "string",
          "description": "The name of the partitions the pull request is queued in."
        },
        {
          "key": "queue-position",
          "type": "number",
          "description": "The position of the pull request in its queue if queued.\nThe first pull request in the queue has position 0.\nThe value is set to -1 if the pull request is not queued.\nNB: If you are using partitions, this condition returns the maximum position of the pull request from all the partitions it is queued in."
        },
        {
          "key": "queue-dequeue-reason",
          "type": "string",
          "enum": [
            "pr-merged",
            "pr-dequeued",
            "pr-ahead-dequeued",
            "pr-ahead-failed-to-merge",
            "pr-with-higher-priority-queued",
            "pr-queued-twice",
            "speculative-check-number-reduced",
            "checks-timeout",
            "checks-failed",
            "queue-rule-missing",
            "unexpected-queue-change",
            "pr-frozen-no-cascading",
            "target-branch-missing",
            "target-branch-changed",
            "pr-unexpectedly-failed-to-merge",
            "batch-max-failure-resolution-attempts",
            "pr-checks-stopped-because-merge-queue-pause",
            "conflict-with-base-branch",
            "conflict-with-pull-ahead",
            "branch-update-failed"
          ],
          "description": "A dequeue code is associated to each specific reason for when a pull request has been disembarked from the merge queue."
        },
        {
          "$ref": "#/definitions/TimestampOrRelativeTimestamp",
          "key": "queued-at",
          "description": "The time the pull request was queued at for merge."
        },
        {
          "$ref": "#/definitions/TimestampOrRelativeTimestamp",
          "key": "queue-merge-started-at",
          "type": "relativeTimestamp",
          "description": "The time the pull request mergeability checks have started at. \nNB: This attribute does not work when using Partition Rules."
        },
        {
          "key": "repository-full-name",
          "type": "string",
          "description": "The current repository full name (complete version with the organization name)."
        },
        {
          "key": "repository-name",
          "type": "string",
          "description": "The current repository name (short version without the organization name)."
        },
        {
          "key": "review-requested",
          "$ref": "#/definitions/GitHubLoginOrTeam",
          "description": "The list of GitHub user or team login that were requested to review the pull request. Team logins are prefixed with the @ character and must belong to the repository organization. This only matches reviewers with admin, write or maintain permission on the repository."
        },
        {
          "key": "review-threads-resolved",
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The list of bodies associated to review threads that are marked as resolved by GitHub."
        },
        {
          "key": "review-threads-unresolved",
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The list of bodies associated to review threads that are NOT marked as resolved by GitHub."
        },
        {
          "key": "schedule",
          "type": "string",
          "description": "The current time will be compared against this schedule to un/validate this attribute."
        },
        {
          "key": "title",
          "type": "string",
          "description": "The title of the pull request."
        },
        {
          "$ref": "#/definitions/TimestampOrRelativeTimestamp",
          "key": "updated-at",
          "description": "The time the pull request was updated at."
        }
      ]
    },
    "StringArray": {
      "type": "array",
      "description": "list of string",
      "items": {
        "type": "string"
      },
      "uniqueItems": true,
      "default": []
    },
    "LoginArray": {
      "$id": "/definitions/LoginArray",
      "default": [
        ""
      ],
      "anyOf": [
        {
          "$ref": "#/definitions/StringArray"
        },
        {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "login": {
                "type": "string"
              },
              "weight": {
                "type": "number"
              }
            }
          }
        }
      ]
    },
    "GitHubLogin": {
      "$id": "/definitions/GitHubLogin",
      "description": "GitHub login",
      "type": "string"
    },
    "GitHubTeam": {
      "$id": "/definitions/GitHubTeam",
      "description": "GitHub team",
      "type": "string"
    },
    "GitHubLoginOrTeam": {
      "$id": "/definitions/GitHubLoginOrTeam",
      "description": "GitHub login or team",
      "anyOf": [
        {
          "$ref": "#/definitions/GitHubLogin"
        },
        {
          "$ref": "#/definitions/GitHubTeam"
        }
      ]
    },
    "BranchName": {
      "$id": "/definitions/BranchName",
      "description": "branch name",
      "type": "string"
    },
    "GitHubActionsWorkflow": {
      "$id": "/definitions/GitHubActionsWorkflow",
      "description": "A GitHub Action workflow action",
      "type": "object",
      "properties": {
        "dispatch": {
          "$ref": "#/definitions/GitHubActionsWorkflowDispatch",
          "description": "The list of workflows to dispatch via the action."
        }
      }
    },
    "GitHubActionsWorkflowDispatch": {
      "$id": "/definitions/GitHubActionsWorkflowDispatch",
      "description": "A GitHub Actions workflow dispatch",
      "type": "object",
      "properties": {
        "workflow": {
          "type": "string",
          "description": "The name of the .yaml GitHub Workflow file with its extension."
        },
        "inputs": {
          "type": "object",
          "description": "The inputs passed to your workflow execution if any."
        }
      }
    },
    "Template": {
      "$id": "/definitions/Template",
      "description": "template",
      "default": "",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "type": "null"
        }
      ]
    },
    "Duration": {
      "$id": "/definitions/Duration",
      "type": "string",
      "default": "",
      "description": "duration"
    },
    "ConditionString": {
      "$id": "/definitions/ConditionString",
      "type": "string",
      "default": ""
    },
    "TemplateArray": {
      "$id": "/definitions/TemplateArray",
      "type": "array",
      "description": "list of template",
      "default": [],
      "items": {
        "$ref": "#/definitions/Template"
      }
    },
    "LabelArray": {
      "$id": "/definitions/LabelArray",
      "type": "array",
      "default": [],
      "items": {
        "$ref": "#/definitions/Template"
      }
    },
    "UserArray": {
      "$id": "/definitions/UserArray",
      "type": "array",
      "default": [],
      "items": {
        "$ref": "#/definitions/Template"
      }
    },
    "BranchArray": {
      "$id": "/definitions/BranchArray",
      "type": "array",
      "default": [],
      "items": {
        "type": "string"
      }
    },
    "PriorityRule": {
      "$id": "/definitions/PriorityRule",
      "description": "priority rule",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the rule.",
          "type": "string"
        },
        "conditions": {
          "description": "The list of conditions that needs to match to assign priority to the pull request.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ConditionString"
          }
        },
        "priority": {
          "description": "The priority of the pull request.",
          "$ref": "#/definitions/Priority"
        }
      }
    },
    "Priority": {
      "$id": "/definitions/Priority",
      "description": "priority: `low`, `medium`, `high` or a value between 1 and 10000",
      "anyOf": [
        {
          "type": "number",
          "minimum": 1,
          "maximum": 10000
        },
        {
          "enum": [
            "low",
            "medium",
            "high"
          ]
        }
      ]
    },
    "MergeMethod": {
      "$id": "/definitions/MergeMethod",
      "description": "merge method: `merge`, `squash`, `rebase` or `fast-forward`",
      "enum": [
        "merge",
        "squash",
        "rebase",
        "fast-forward"
      ]
    },
    "Timestamp": {
      "$id": "/definitions/Timestamp",
      "description": "Timestamp",
      "type": "string"
    },
    "RelativeTimestamp": {
      "$id": "/definitions/RelativeTimestamp",
      "type": "string"
    },
    "TimestampInterval": {
      "$id": "/definitions/TimestampInterval",
      "type": "string"
    },
    "TimestampOrRelativeTimestamp": {
      "$id": "/definitions/TimestampOrRelativeTimestamp",
      "description": "Timestamp or relative timestamp",
      "anyOf": [
        {
          "$ref": "#/definitions/Timestamp"
        },
        {
          "$ref": "#/definitions/RelativeTimestamp"
        }
      ]
    },
    "TimestampOrTimestampInterval": {
      "$id": "/definitions/TimestampOrTimestampInterval",
      "anyOf": [
        {
          "$ref": "#/definitions/Timestamp"
        },
        {
          "$ref": "#/definitions/TimestampInterval"
        }
      ]
    },
    "Commit": {
      "$id": "/definitions/Commit",
      "description": "Commit",
      "type": "object",
      "properties": {
        "sha": {
          "description": "Commit sha",
          "type": "string"
        },
        "parents": {
          "description": "List of parents sha",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "commit_message": {
          "description": "The commit message",
          "type": "string"
        },
        "commit_verification_verified": {
          "type": "boolean",
          "description": "Whether the commit was verified by GitHub"
        },
        "author": {
          "description": "The commit author",
          "type": "string"
        },
        "date_author": {
          "description": "The date the commit was authored",
          "$ref": "#/definitions/Timestamp"
        },
        "email_author": {
          "description": "The email address of the commit author",
          "type": "string"
        },
        "committer": {
          "description": "The committer",
          "type": "string"
        },
        "date_committer": {
          "description": "The date the commit was committed",
          "$ref": "#/definitions/Timestamp"
        },
        "email_author": {
          "description": "The email address of the committer",
          "type": "string"
        }
      }
    },
    "CommitAuthor": {
      "$id": "/definitions/CommitAuthor",
      "description": "Commit author",
      "type": "object",
      "properties": {
        "name": {
          "description": "Author name",
          "type": "string"
        },
        "email": {
          "description": "Author email address",
          "type": "string"
        }
      }
    },
    "PullRequestRule": {
      "$id": "/definitions/PullRequestRule",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the rule. This is used when reporting information about a rule. It's not possible to have two rules with the same name."
        },
        "conditions": {
          "type": "array",
          "description": "A list of conditions that must match against the pull request for the rule to be applied.",
          "items": {
            "$ref": "#/definitions/RuleCondition"
          }
        },
        "actions": {
          "description": "A dictionary made of actions that will be executed on the matching pull requests.",
          "$ref": "#/definitions/Actions"
        }
      },
      "required": [
        "conditions",
        "name",
        "actions"
      ],
      "title": "PullRequestRule"
    },
    "PartitionRule": {
      "$id": "/definitions/PartitionRule",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "type": "string",
          "default": "",
          "description": "The name of the partition."
        },
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleCondition"
          },
          "description": "List of conditions to determine the partition(s) in which the pull request will be queued. If a pull request matches no partition, it is added to the fallback partition if defined, otherwise it is added to every partition."
        },
        "fallback_partition": {
          "description": "Allow the partition to work as the fallback partition.",
          "type": "boolean",
          "default": false
        }
      }
    },
    "QueueRule": {
      "$id": "/definitions/QueueRule",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "description": "The name of the merge queue.",
          "type": "string"
        },
        "queue_conditions": {
          "description": "The list of conditions that needs to match to queue the pull request.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleCondition"
          }
        },
        "require_branch_protection": {
          "type": "boolean",
          "default": true,
          "description": "Whether branch protections are required for queueing pull requests."
        },
        "merge_conditions": {
          "description": "The list of conditions to match to get the queued pull request merged. This automatically includes the `queue_conditions`. In case of speculative merge pull request, the merge conditions starting by `check-` are evaluated against the temporary pull request instead of the original one.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/RuleCondition"
          }
        },
        "branch_protection_injection_mode": {
          "type": "string",
          "enum": [
            "queue",
            "merge",
            "none"
          ],
          "description": "Branch protections conditions injection mode to use.\n- `queue` will inject branch protections conditions as required conditions for queuing and merging pull requests.\n- `merge` will inject branch protections conditions as required conditions only for merging pull requests.\n- `none` will disable branch protections. This mode is supported only on queues using a `merge_bot_account` with admin rights."
        },
        "allow_checks_interruption": {
          "description": "Allow interrupting the ongoing checks when a pull request with higher priority enters in the queue. If false, pull request with higher priority will be inserted just after the pull requests that have checks running.",
          "type": "boolean",
          "default": true
        },
        "allow_inplace_checks": {
          "description": "Allow to update/rebase the original pull request to check its mergeability when first in the queue and not part of a batch or speculative check.",
          "type": "boolean",
          "default": true
        },
        "allow_queue_branch_edit": {
          "description": "When creating a branch for a queue, if the code of this branch is edited by an entity external to Mergify, Mergify un-queues all pull requests embarked in the branch and report the issue as a failure. If set to true, Mergify will allow such modifications and trust the content of the branch. Make sure only Mergify and your external application are allowed to edit these branches.",
          "type": "boolean",
          "default": false
        },
        "batch_max_failure_resolution_attempts": {
          "type": "number",
          "description": "The number of attempts to resolve a batch failure before unqueueing pull requests. By default, Mergify will attempt to resolve a batch failure by splitting the batch multiple times until it finds the root cause of the failure. You can stop this process earlier by limiting the number of resolution attempts. Setting this to 0 will unqueue all the pull requests from a batch when a batch fails."
        },
        "batch_max_wait_time": {
          "description": "The maximum amount of time to wait before creating a batch when the batch is not full.",
          "$ref": "#/definitions/Duration",
          "default": "30 s"
        },
        "batch_size": {
          "description": "The maximum number of pull requests per speculative check in the queue. Must be between 1 and 20.",
          "type": "number",
          "default": 1,
          "minimum": 1,
          "maximum": 20
        },
        "checks_timeout": {
          "description": "The amount of time Mergify waits for pending checks to return before unqueueing pull requests. This cannot be less than 60 seconds.",
          "$ref": "#/definitions/Duration"
        },
        "commit_message_template": {
          "description": "Template to use as the commit message when using the `merge` or `squash` merge method.",
          "$ref": "#/definitions/Template"
        },
        "disallow_checks_interruption_from_queues": {
          "description": "The list of higher priorities queue that are not allowed to interrupt the ongoing checks of this queue.",
          "$ref": "#/definitions/StringArray"
        },
        "draft_bot_account": {
          "description": "Mergify can impersonate a GitHub user to create its draft pull requests. If no `draft_bot_account` is set, Mergify creates the draft pull request itself. The user account must have already been logged in Mergify dashboard once and have admin, write or maintain permission.",
          "type": "string"
        },
        "merge_bot_account": {
          "description": "Mergify can impersonate a GitHub user to merge pull requests. If no `merge_bot_account` is set, Mergify will merge the pull request itself. The user account must have already been logged in Mergify dashboard once and have write or maintain permission.",
          "$ref": "#/definitions/Template"
        },
        "merge_method": {
          "description": "Merge method to use. Possible values are `merge`, `squash`, `rebase` or `fast-forward`. `fast-forward` is not supported on queues with `speculative_checks > 1`, `batch_size > 1`, or with `allow_inplace_checks` set to false.",
          "$ref": "#/definitions/MergeMethod"
        },
        "priority_rules": {
          "description": "The list of priority rules a pull request can match in order to be prioritized when added to a queue. The rule with the highest priority value wins.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PriorityRule"
          }
        },
        "queue_branch_merge_method": {
          "description": "If set to `fast-forward`, Mergify will merge the draft pull request instead of merging the original pull request that has been checked. This only works when the queue action `merge_method` is set to its default `merge`.",
          "type": "string",
          "default": "none"
        },
        "queue_branch_prefix": {
          "description": "The prefix used to name the branch of draft pull requests.",
          "type": "string",
          "default": "mergify/merge-queue/"
        },
        "speculative_checks": {
          "description": "The maximum number of checks to run in parallel in the queue. Must be between 1 and 20.",
          "type": "number",
          "default": 1,
          "minimum": 1,
          "maximum": 20
        },
        "update_method": {
          "description": "Method to use to update the pull request with its base branch when the speculative check is done in-place. Possible values:\n- `merge` to merge the base branch into the pull request.\n- `rebase` to rebase the pull request against its base branch.",
          "type": "string",
          "enum": [
            "merge",
            "rebase"
          ]
        },
        "update_bot_account": {
          "description": "For merging or rebasing branches, Mergify might have to impersonate a GitHub user. You can specify the account to use with this option. If no `update_bot_account` is set, Mergify uses the author of the PR. The user account must have already been logged in Mergify dashboard once.",
          "$ref": "#/definitions/Template"
        }
      }
    },
    "RuleCondition": {
      "$id": "/definitions/RuleCondition",
      "description": "condition",
      "anyOf": [
        {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/RuleCondition"
              },
              {
                "$ref": "#/definitions/ConditionString"
              }
            ]
          }
        },
        {
          "type": "object",
          "propertyNames": {
            "enum": [
              "or",
              "and",
              "not"
            ]
          },
          "patternProperties": {
            "": {
              "$ref": "#/definitions/RuleCondition"
            }
          }
        },
        {
          "$ref": "#/definitions/ConditionString"
        }
      ],
      "title": "RuleCondition"
    },
    "Actions": {
      "description": "action",
      "type": "object",
      "properties": {
        "assign": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "add_users": {
              "default": "",
              "description": "The users to assign to the pull request.",
              "$ref": "#/definitions/UserArray"
            },
            "remove_users": {
              "default": "",
              "description": "The users to remove from assignees.",
              "$ref": "#/definitions/UserArray"
            }
          }
        },
        "backport": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "assignees": {
              "default": "",
              "description": "Users to assign the newly created pull request. As the type is a data type template, you could use, e.g., `{{author}}` to assign the pull request to its original author.",
              "$ref": "#/definitions/TemplateArray"
            },
            "body": {
              "description": "The pull request body.",
              "default": "This is an automatic backport of pull request #{{number}} done by [Mergify](https://mergify.com).\n{{cherry_pick_error}}",
              "$ref": "#/definitions/Template"
            },
            "bot_account": {
              "description": "Mergify can impersonate a GitHub user to backport a pull request. If no `bot_account` is set, Mergify backports the pull request itself.",
              "default": "",
              "$ref": "#/definitions/Template"
            },
            "branches": {
              "description": "The list of branches the pull request should be copied to.",
              "default": "[]",
              "$ref": "#/definitions/BranchArray"
            },
            "ignore_conflicts": {
              "description": "Whether to create the pull requests even if they are conflicts when cherry-picking the commits.",
              "type": "boolean",
              "default": true
            },
            "labels": {
              "description": "The list of labels to add to the created pull requests.",
              "default": "[]",
              "$ref": "#/definitions/StringArray"
            },
            "label_conflicts": {
              "default": "conflicts",
              "description": "The label to add to the created pull request if it has conflicts and `ignore_conflicts` is set to `true`.",
              "type": "string"
            },
            "regexes": {
              "description": "The list of regexes to find branches the pull request should be copied to.",
              "default": "[]",
              "$ref": "#/definitions/StringArray"
            },
            "title": {
              "description": "The pull request title.",
              "default": "{{ title }} (backport #{{ number }})",
              "$ref": "#/definitions/Template"
            }
          }
        },
        "close": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "message": {
              "default": "This pull request has been automatically closed by Mergify.",
              "description": "The `message` to write as a comment after closing the pull request.",
              "$ref": "#/definitions/Template"
            }
          }
        },
        "copy": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "assignees": {
              "description": "Users to assign the newly created pull request. As the type is Template, you could use, e.g., {{author}} to assign the pull request to its original author.",
              "default": "",
              "$ref": "#/definitions/TemplateArray"
            },
            "body": {
              "description": "The pull request body.",
              "default": "This is an automatic copy of pull request #{{number}} done by [Mergify](https://mergify.com).\n{{cherry_pick_error}}",
              "$ref": "#/definitions/Template"
            },
            "bot_account": {
              "description": "Mergify can impersonate a GitHub user to copy a pull request. If no bot_account is set, Mergify copies the pull request itself.",
              "default": "",
              "$ref": "#/definitions/Template"
            },
            "branches": {
              "description": "The list of branches the pull request should be copied to.",
              "default": "[]",
              "$ref": "#/definitions/BranchArray"
            },
            "ignore_conflicts": {
              "description": "Whether to create the pull requests even if they are conflicts when cherry-picking the commits.",
              "default": "true",
              "type": "boolean"
            },
            "labels": {
              "description": "The list of labels to add to the created pull requests.",
              "default": "[]",
              "$ref": "#/definitions/StringArray"
            },
            "label_conflicts": {
              "description": "The label to add to the created pull request if it has conflicts and ignore_conflicts is set to true.",
              "default": "conflicts",
              "type": "string"
            },
            "regexes": {
              "description": "The list of regexes to find branches the pull request should be copied to.",
              "default": "[]",
              "$ref": "#/definitions/StringArray"
            },
            "title": {
              "description": "The pull request title.",
              "default": "{{ title }} (copy #{{ number }})",
              "$ref": "#/definitions/Template"
            }
          }
        },
        "comment": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "bot_account": {
              "description": "Mergify can impersonate a GitHub user to comment a pull request. If no `bot_account` is set, Mergify will comment the pull request itself.",
              "$ref": "#/definitions/Template"
            },
            "message": {
              "description": "The message to write as a comment.",
              "$ref": "#/definitions/Template"
            }
          }
        },
        "delete_head_branch": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "force": {
              "type": "boolean",
              "default": false,
              "description": "If set to `true`, the branch will be deleted even if another pull request depends on the head branch. GitHub will therefore close the dependent pull requests."
            }
          }
        },
        "dismiss_reviews": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "approved": {
              "description": "If set to `true`, all the approving reviews will be removed when the pull request is updated. If set to `false`, nothing will be done. If set to a list, each item should be the GitHub login of a user whose review will be removed. If set to `from_requested_reviewers`, the list of requested reviewers will be used to get whose review will be removed.",
              "default": true,
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "changes_requested": {
              "description": "If set to `true`, all the reviews requesting changes will be removed when the pull request is updated. If set to `false`, nothing will be done. If set to a list, each item should be the GitHub login of a user whose review will be removed. If set to `from_requested_reviewers`, the list of requested reviewers will be used to get whose review will be removed.",
              "default": true,
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "message": {
              "description": "The message to post when dismissing the review.",
              "default": "Pull request has been modified.",
              "$ref": "#/definitions/Template"
            },
            "when": {
              "description": "If set to `synchronize`, the action will run only if the pull request commits changed. Otherwise, it will run each time the rule matches.",
              "default": "synchronize",
              "enum": [
                "synchronize",
                "always"
              ]
            }
          }
        },
        "edit": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "draft": {
              "description": "If the pull request should be a draft (`true`) or the other way around (`false`).",
              "default": "None",
              "type": "boolean"
            }
          }
        },
        "label": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "add": {
              "default": "[]",
              "description": "The list of labels to add.",
              "$ref": "#/definitions/LabelArray"
            },
            "remove": {
              "default": "[]",
              "description": "The list of labels to remove.",
              "$ref": "#/definitions/LabelArray"
            },
            "toggle": {
              "default": "[]",
              "description": "Toggle labels in the list based on the conditions. If all the conditions are a success, all the labels in the list will be added, otherwise, they will all be removed.",
              "$ref": "#/definitions/LabelArray"
            },
            "remove_all": {
              "description": "Remove all labels from the pull request.",
              "type": "boolean",
              "default": false
            }
          }
        },
        "github_actions": {
          "type": [
            "object"
          ],
          "properties": {
            "workflow": {
              "description": "The workflow to act on.",
              "$ref": "#/definitions/GitHubActionsWorkflow"
            }
          }
        },
        "merge": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "commit_message_template": {
              "description": "Template to use as the commit message when using the `merge` or `squash` merge method.",
              "$ref": "#/definitions/Template"
            },
            "merge_bot_account": {
              "description": "Mergify can impersonate a GitHub user to merge pull requests. If no `merge_bot_account` is set, Mergify will merge the pull request itself. The user account **must** have already been logged in Mergify dashboard once and have **write** or **maintain** permission.",
              "$ref": "#/definitions/Template"
            },
            "method": {
              "description": "Merge method to use. Possible values are `merge`, `squash`, `rebase` or `fast-forward`.",
              "$ref": "#/definitions/MergeMethod",
              "default": "merge"
            },
            "allow_merging_configuration_change": {
              "type": "boolean",
              "description": "Allow merging Mergify configuration change.",
              "default": false
            }
          }
        },
        "post_check": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "success_conditions": {
              "type": "array",
              "description": "List of conditions to match to mark the pull request check as succeeded, otherwise, it will be marked as failing. If unset, the conditions from the rule that triggers this action are used.",
              "default": [
                ""
              ],
              "items": {
                "$ref": "#/definitions/RuleCondition"
              }
            },
            "summary": {
              "description": "The summary of the check.",
              "$ref": "#/definitions/Template"
            },
            "title": {
              "description": "The title of the check.",
              "$ref": "#/definitions/Template"
            }
          }
        },
        "queue": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "autosquash": {
              "type": "boolean",
              "default": true,
              "description": "This option is relevant only if you do inplace checks and if you use the `rebase` option of the `update_method`. It will automatically squash your commits beginning by `squash!`, `fixup!` or `amend!`, just like the option with the same name when doing a `git rebase`."
            },
            "commit_message_template": {
              "description": "Template to use as the commit message when using the `merge` or `squash` merge method. This option has been moved under the queue rules section of the configuration and will be removed from this section in the future.",
              "$ref": "#/definitions/Template"
            },
            "merge_bot_account": {
              "description": "Mergify can impersonate a GitHub user to merge pull requests. If no `merge_bot_account` is set, Mergify will merge the pull request itself. The user account **must** have already been logged in Mergify dashboard once and have **write** or **maintain** permission.\n This option overrides the value defined in the queue rules section of the configuration.",
              "$ref": "#/definitions/Template"
            },
            "merge_method": {
              "description": "Merge method to use. Possible values are `merge`, `squash`, `rebase` or `fast-forward`. `fast-forward` is not supported on queues with `speculative_checks > 1`, `batch_size > 1`, or with `allow_inplace_checks` set to `false`.\n This option overrides the value defined in the queue rules section of the configuration.",
              "type": "string",
              "enum": [
                "merge",
                "squash",
                "rebase",
                "fast-forward"
              ]
            },
            "name": {
              "type": "string",
              "default": "default",
              "description": "The name of the queue where the pull request should be added. If no name is set, `queue_conditions` will be applied instead."
            },
            "priority": {
              "$ref": "#/definitions/Priority",
              "default": "medium",
              "deprecated": true,
              "description": "To set your priorities, you should now use `priority_rules`. This sets the priority of the pull request in the queue. The pull request with the highest priority is merged first. `low`, `medium`, `high` are aliases for `1000`, `2000`, `3000`."
            },
            "allow_merging_configuration_change": {
              "type": "boolean",
              "default": false,
              "description": "Allow merging Mergify configuration change."
            },
            "require_branch_protection": {
              "type": "boolean",
              "default": true,
              "deprecated": true,
              "description": "Whether branch protections are required for queueing pull requests."
            },
            "update_bot_account": {
              "$ref": "#/definitions/Template",
              "description": "For certain actions, such as rebasing branches, Mergify has to impersonate a GitHub user. You can specify the account to use with this option. If no `update_bot_account` is set, Mergify picks randomly one of the organization users instead. The user account **must** have already been logged in Mergify dashboard once.\n\n This option overrides the value defined in the queue rules section of the configuration."
            },
            "update_method": {
              "description": "`merge` for all merge methods except `fast-forward` where `rebase` is used Method to use to update the pull request with its base branch when the speculative check is done in-place. Possible values: \n * `merge` to merge the base branch into the pull request.\n* `rebase` to rebase the pull request against its base branch. \n This option overrides the value defined in the queue rules section of the configuration.",
              "enum": [
                "merge",
                "rebase"
              ]
            }
          }
        },
        "rebase": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "autosquash": {
              "type": "boolean",
              "default": true,
              "description": "When set to `True`, commits starting with `fixup!`, `squash!` and `amend!`are squashed during the rebase."
            },
            "bot_account": {
              "$ref": "#/definitions/Template",
              "description": "To rebase, Mergify needs to impersonate a GitHub user. You can specify the account to use with this option. If no `bot_account` is set, Mergify picks the pull request author. The user account **must** have already been logged in Mergify dashboard once."
            }
          }
        },
        "request_reviews": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "users": {
              "description": "The username to request reviews from.",
              "$ref": "#/definitions/LoginArray"
            },
            "users_from_teams": {
              "description": "The team names to get the list of users to request reviews from.",
              "$ref": "#/definitions/LoginArray"
            },
            "teams": {
              "description": "The team name to request reviews from.",
              "$ref": "#/definitions/LoginArray"
            },
            "bot_account": {
              "description": "Mergify can impersonate a GitHub user to request a review on a pull request. If no `bot_account` is set, Mergify will request the review itself.",
              "$ref": "#/definitions/Template"
            },
            "random_count": {
              "description": "Pick random users and teams from the provided lists. When `random_count` is specified, `users` and `teams` can be a dictionary where the key is the login and the value is the weight to use. Weight must be between 1 and 65535 included.",
              "type": "number",
              "minimum": 1,
              "maximum": 15
            }
          }
        },
        "review": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "bot_account": {
              "description": "Mergify can impersonate a GitHub user to review a pull request. If no `bot_account` is set, Mergify will review the pull request itself.",
              "$ref": "#/definitions/Template"
            },
            "message": {
              "description": "The message to write as a comment.",
              "$ref": "#/definitions/Template"
            },
            "type": {
              "default": "APPROVE",
              "description": "The kind of review, can be `APPROVE`, `REQUEST_CHANGES`, `COMMENT`",
              "enum": [
                "APPROVE",
                "REQUEST_CHANGES",
                "COMMENT"
              ]
            }
          }
        },
        "update": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "bot_account": {
              "description": "Mergify can impersonate a GitHub user to review a pull request. If no `bot_account` is set, Mergify will update the pull request itself.",
              "$ref": "#/definitions/Template"
            }
          }
        },
        "squash": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "bot_account": {
              "description": "Mergify can impersonate a GitHub user to review a pull request. If no `bot_account` is set, Mergify will squash the pull request itself.",
              "$ref": "#/definitions/Template"
            },
            "commit_message": {
              "description": "Defines what commit message to use for the squashed commit if no commit message is defined in the pull request body. Possible values are:\n- `all-commits` to use the same format as GitHub squashed merge commit.\n- `first-commit` to use the message of the first commit of the pull request.\n- `title+body` means to use the title and body from the pull request itself as the commit message. The pull request number will be added to end of the title.",
              "enum": [
                "all-commits",
                "first-commit",
                "title+body"
              ],
              "default": "all-commits"
            }
          }
        }
      },
      "title": "Actions"
    }
  }
}
